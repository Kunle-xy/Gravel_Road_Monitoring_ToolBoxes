### CODE GENERATED BY RUT-IOWADOT.pyt - DO NOT EDIT ###
#  --- ALL CODES ARE WRITTEN BY KUNLE OGUNTOYE, PhD Student at Iowa State University ---
#  --- CONTACT: oguntoye@IASTATE.EDU
#  --- DATE: 2024-06-20
#  --- PURPOSE: Custom script tool to detect and visualize rutting severity within a polygon using a DEM, with optional neighbor frequency study.
import arcpy
import os
import numpy as np
import pandas as pd
from shapely.geometry import Polygon, LineString
from collections import defaultdict
import rasterio
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import math
import plotly.colors

def hex_to_rgba(hex_color, alpha):
    """Convert a hex color like #1f77b4 to rgba string with given alpha."""
    h = hex_color.lstrip('#')
    r = int(h[0:2], 16)
    g = int(h[2:4], 16)
    b = int(h[4:6], 16)
    return f"rgba({r},{g},{b},{alpha})"

class RuttingPolygonTool(object):
    def __init__(self):
        self.label = "Rutting Severity Detector"
        self.description = "Detects and visualizes rutting severity within a polygon using a DEM, with optional neighbor frequency study."

    def getParameterInfo(self):
        params = []

        param0 = arcpy.Parameter(
            displayName="Input Polygon Feature",
            name="in_polygon",
            datatype="Feature Layer",
            parameterType="Required",
            direction="Input")

        param1 = arcpy.Parameter(
            displayName="DEM Raster File",
            name="dem_path",
            datatype="DERasterDataset",
            parameterType="Required",
            direction="Input")

        param2 = arcpy.Parameter(
            displayName="Sampling frequency per 100 pixels",
            name="dy_freq",
            datatype="Long",
            parameterType="Required",
            direction="Input")
        param2.value = 3

        param3 = arcpy.Parameter(
            displayName="Rutting Width, dx in meters",
            name="dx",
            datatype="Double",
            parameterType="Required",
            direction="Input")
        param3.value = 0.1

        param4 = arcpy.Parameter(
            displayName="Try neighboring sampling frequencies",
            name="neighbor_eval",
            datatype="Boolean",
            parameterType="Optional",
            direction="Input")
        param4.value = False

        param5 = arcpy.Parameter(
            displayName="Neighbor range, plus or minus",
            name="neighbor_range",
            datatype="Long",
            parameterType="Optional",
            direction="Input")
        param5.value = 2

        param6 = arcpy.Parameter(
            displayName="Output Plot, HTML",
            name="output_html",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        param6.filter.list = ["html"]

        params.extend([param0, param1, param2, param3, param4, param5, param6])
        return params

    def isLicensed(self):
        return True

    def updateParameters(self, parameters):
        if parameters[6].valueAsText:
            output_path = parameters[6].valueAsText
            if not output_path.lower().endswith('.html'):
                parameters[6].value = output_path + '.html'
        return

    def updateMessages(self, parameters):
        if parameters[0].valueAsText:
            desc = arcpy.Describe(parameters[0].valueAsText)
            if desc.shapeType != "Polygon":
                parameters[0].setErrorMessage("Input feature must be a polygon.")

        if parameters[1].valueAsText:
            dem_path = parameters[1].valueAsText
            if not os.path.exists(dem_path):
                parameters[1].setErrorMessage("DEM file does not exist.")
            elif not dem_path.lower().endswith(('.tif', '.tiff', '.img')):
                parameters[1].setWarningMessage("DEM file should be a raster format, for example .tif or .img.")

        if parameters[2].value is not None and int(parameters[2].value) <= 0:
            parameters[2].setErrorMessage("Sampling frequency per 100 pixels must be greater than zero.")

        if parameters[3].value is not None and float(parameters[3].value) <= 0:
            parameters[3].setErrorMessage("Rutting width must be greater than zero.")

        if parameters[5].value is not None and int(parameters[5].value) < 1:
            parameters[5].setWarningMessage("Neighbor range is less than one, it will be clamped to one at run time.")

        if parameters[6].valueAsText:
            output_path = parameters[6].valueAsText
            if not output_path.lower().endswith('.html'):
                parameters[6].setErrorMessage("Output file must have a .html extension.")
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                parameters[6].setErrorMessage("Output directory does not exist.")
        return

    def execute(self, parameters, messages):
        try:
            arcpy.AddMessage("Starting Rutting Severity Detection for Polygon...")

            in_polygon = parameters[0].valueAsText
            dem_path = parameters[1].valueAsText
            user_freq = int(parameters[2].valueAsText)
            dx = float(parameters[3].valueAsText)
            neighbor_eval = bool(parameters[4].value) if parameters[4].value is not None else False
            user_range = int(parameters[5].value) if parameters[5].value is not None else 2
            user_range = max(1, user_range)
            output_html = parameters[6].valueAsText

            if neighbor_eval:
                start_f = max(1, user_freq - user_range)
                end_f = user_freq + user_range
                frequencies = list(range(start_f, end_f + 1))
                arcpy.AddMessage(f"Neighbor evaluation on, range plus or minus {user_range}, frequencies to run, {frequencies}")
            else:
                frequencies = [user_freq]
                arcpy.AddMessage(f"Single frequency run at f, {user_freq}")

            arcpy.AddMessage("Checking polygon selection...")
            desc = arcpy.Describe(in_polygon)
            if desc.FIDSet:
                arcpy.AddMessage("Using selected polygon features only.")
                in_polygon = arcpy.management.MakeFeatureLayer(in_polygon, "selected_polygons")
            else:
                arcpy.AddMessage("No selection detected, using all polygon features.")

            arcpy.AddMessage("Extracting geometry from polygon feature...")
            selected_polygons = []
            polygon_srs = desc.spatialReference
            arcpy.AddMessage(f"Polygon spatial reference, {polygon_srs.name}")
            with arcpy.da.SearchCursor(in_polygon, ["SHAPE@"]) as cursor:
                for row in cursor:
                    selected_polygons.append(row[0])
            if len(selected_polygons) > 1:
                arcpy.AddWarning("Multiple polygons detected, processing only the first selected polygon.")
            if not selected_polygons:
                raise arcpy.ExecuteError("No polygon features found.")
            poly_geom = selected_polygons[0]

            with rasterio.open(dem_path) as src:
                band1 = src.read(1)
                bounds = src.bounds
                dem_crs = src.crs
                dem_srs = arcpy.SpatialReference()
                dem_srs.loadFromString(str(dem_crs))
                arcpy.AddMessage(f"DEM spatial reference, {dem_srs.name}")
                arcpy.AddMessage(f"DEM resolution, x, {src.res[0]:.4f} m, y, {src.res[1]:.4f} m")
                arcpy.AddMessage(f"DEM bounds, left, {bounds.left:.4f}, bottom, {bounds.bottom:.4f}, right, {bounds.right:.4f}, top, {bounds.top:.4f}")
                arcpy.AddMessage(f"Depth range in DEM, meters, Min, {np.nanmin(band1):.4f}, Max, {np.nanmax(band1):.4f}")

                coords = [(pt.X, pt.Y) for part in poly_geom for pt in part if pt]
                polygon = Polygon(coords)
                poly_bounds = polygon.bounds
                if not (poly_bounds[0] <= bounds.right and poly_bounds[2] >= bounds.left and
                        poly_bounds[1] <= bounds.top and poly_bounds[3] >= bounds.bottom):
                    arcpy.AddWarning("Polygon does not intersect DEM extent, check spatial alignment.")

                if polygon_srs.name != dem_srs.name:
                    arcpy.AddWarning("Spatial reference mismatch, reprojecting polygon to DEM spatial reference.")
                    temp_poly = "memory/temp_poly"
                    arcpy.management.Project(in_polygon, temp_poly, dem_srs)
                    with arcpy.da.SearchCursor(temp_poly, ["SHAPE@"]) as cursor:
                        poly_geom = next(cursor)[0]
                    arcpy.management.Delete(temp_poly)
                    coords = [(pt.X, pt.Y) for part in poly_geom for pt in part if pt]
                    polygon = Polygon(coords)

                min_x, min_y, max_x, max_y = polygon.bounds

                x_steps = np.arange(min_x, max_x + dx, dx)

                inches_per_meter = 39.3701
                sqm_to_sqft = 10.7639
                min_depth_diff = 0.0127

                elevation_plots = []
                line_data_all = []
                neighbor_summary_rows = []

                severity_levels = ["Low", "Medium", "High"]

                for f in frequencies:
                    pix_m = float(np.mean(np.abs(src.res)))
                    dy = (100.0 / float(f)) * pix_m
                    arcpy.AddMessage(f"Running frequency f, {f}, computed dy, {dy:.4f} m")

                    all_results = defaultdict(list)
                    line_data = []

                    for line_idx, x in enumerate(x_steps):
                        line_coords = [(x, min_y), (x, max_y)]
                        line = LineString(line_coords)
                        clipped_line = line.intersection(polygon)
                        if clipped_line.is_empty or clipped_line.length <= 0:
                            continue

                        length = clipped_line.length
                        distances = np.arange(0, length, dy)
                        if len(distances) < 2:
                            continue

                        sample_points = [clipped_line.interpolate(distance) for distance in distances]
                        sample_points = [pt for pt in sample_points
                                         if bounds.left <= pt.x <= bounds.right and bounds.bottom <= pt.y <= bounds.top]

                        depths = []
                        for pt in sample_points:
                            try:
                                row, col = src.index(pt.x, pt.y)
                                depth = band1[row, col]
                                if depth == -32767:
                                    depth = np.nan
                            except IndexError:
                                depth = np.nan
                            depths.append(depth)

                        if len(depths) < 2 or all(np.isnan(depths)):
                            continue

                        df_input = pd.DataFrame({"section": range(len(depths)), "depth": depths}).dropna()
                        if len(df_input) < 2:
                            continue

                        res = []
                        low = df_input["depth"].iloc[0]
                        idx_low = 0
                        direction_prev = None
                        left_height = None
                        peak_heights = [df_input["depth"].iloc[0]]
                        peak_indices = [0]
                        idx_h1 = 0
                        h1 = low

                        for idx in range(1, len(df_input)):
                            current = df_input["depth"].iloc[idx]
                            previous = df_input["depth"].iloc[idx - 1]
                            direction = "UP" if current > previous else "DOWN"

                            if direction == "UP":
                                if current > peak_heights[-1]:
                                    peak_heights[-1] = current
                                    peak_indices[-1] = idx
                                else:
                                    peak_heights.append(current)
                                    peak_indices.append(idx)

                            if direction_prev == "DOWN" and direction == "UP":
                                low = df_input["depth"].iloc[idx - 1]
                                idx_low = idx - 1
                                if peak_indices:
                                    valid_peaks = [i for i in peak_indices if i <= idx_low]
                                    if valid_peaks:
                                        peak_heights_valid = [peak_heights[peak_indices.index(i)] for i in valid_peaks]
                                        max_peak_idx = peak_heights_valid.index(max(peak_heights_valid))
                                        idx_h1 = valid_peaks[max_peak_idx]
                                        h1 = df_input["depth"].iloc[idx_h1]
                                        left_height = h1 - low
                                    else:
                                        left_height = None
                                else:
                                    left_height = None

                            elif direction_prev == "UP" and direction == "DOWN" and left_height is not None:
                                if peak_indices:
                                    valid_peaks = [i for i in peak_indices if i > idx_low and i <= idx]
                                    if valid_peaks:
                                        peak_heights_valid = [peak_heights[peak_indices.index(i)] for i in valid_peaks]
                                        max_peak_idx = peak_heights_valid.index(max(peak_heights_valid))
                                        idx_h2 = valid_peaks[max_peak_idx]
                                        h2 = df_input["depth"].iloc[idx_h2]
                                        right_height = h2 - low

                                        rut_depth_m = min(h1, h2) - low
                                        rut_depth_in = rut_depth_m * inches_per_meter

                                        if (idx_h2 > idx_low > idx_h1 and
                                            (min(left_height, right_height) >= 0.1 * max(left_height, right_height)) and
                                            rut_depth_m >= min_depth_diff):
                                            width = (idx_h2 - idx_h1) * dy
                                            rut_area = width * dx
                                            rut_area_sqft = rut_area * sqm_to_sqft
                                            res.append([rut_area_sqft, idx_h1, idx_low, idx_h2, rut_depth_m, rut_depth_in])
                                            peak_heights = [h2]
                                            peak_indices = [idx_h2]

                            direction_prev = direction

                        if left_height is not None and peak_indices:
                            valid_peaks = [i for i in peak_indices if i > idx_low]
                            if valid_peaks:
                                peak_heights_valid = [peak_heights[peak_indices.index(i)] for i in valid_peaks]
                                max_peak_idx = peak_heights_valid.index(max(peak_heights_valid))
                                idx_h2 = valid_peaks[max_peak_idx]
                                h2 = df_input["depth"].iloc[idx_h2]
                                right_height = h2 - low
                                rut_depth_m = min(h1, h2) - low
                                rut_depth_in = rut_depth_m * inches_per_meter
                                if (idx_h2 > idx_low > idx_h1 and
                                    (min(left_height, right_height) >= 0.1 * max(left_height, right_height)) and
                                    rut_depth_m >= min_depth_diff):
                                    width = (idx_h2 - idx_h1) * dy
                                    rut_area = width * dx
                                    rut_area_sqft = rut_area * sqm_to_sqft
                                    res.append([rut_area_sqft, idx_h1, idx_low, idx_h2, rut_depth_m, rut_depth_in])

                        if res:
                            if not neighbor_eval:
                                elevation_plots.append({
                                    "line_x": round(x, 4),
                                    "sections": df_input["section"].tolist(),
                                    "depths": df_input["depth"].tolist(),
                                    "ruts": res
                                })

                            for rut in res:
                                rut_area_sqft, idx_h1, idx_low, idx_h2, rut_depth_m, rut_depth_in = rut
                                rut_info = {
                                    "depth": round(rut_depth_in, 4),
                                    "area": round(rut_area_sqft, 4),
                                    "idx_h1": idx_h1,
                                    "idx_low": idx_low,
                                    "idx_h2": idx_h2,
                                    "line_x": round(x, 4),
                                    "severity": None
                                }
                                if rut_depth_in < 1.0 and rut_depth_in > 0.5:
                                    rut_info["severity"] = "Low"
                                    all_results["Low"].append(rut_info)
                                elif 1.0 <= rut_depth_in <= 3.0:
                                    rut_info["severity"] = "Medium"
                                    all_results["Medium"].append(rut_info)
                                elif rut_depth_in > 3.0:
                                    rut_info["severity"] = "High"
                                    all_results["High"].append(rut_info)

                                line_data.append(rut_info)

                    for sev in severity_levels:
                        items = all_results.get(sev, [])
                        depths = np.array([it["depth"] for it in items], dtype=float) if items else np.array([])
                        areas = np.array([it["area"] for it in items], dtype=float) if items else np.array([])
                        row = {
                            "Frequency": f,
                            "Severity": sev,
                            "Count": int(len(items)),
                            "Mean Depth (in)": float(np.nanmean(depths)) if depths.size else np.nan,
                            "Std Depth (in)": float(np.nanstd(depths)) if depths.size else np.nan,
                            "Mean Area (ft²)": float(np.nanmean(areas)) if areas.size else np.nan,
                            "Std Area (ft²)": float(np.nanstd(areas)) if areas.size else np.nan,
                            "Total Area (ft²)": float(np.nansum(areas)) if areas.size else 0.0,
                        }
                        neighbor_summary_rows.append(row)

                    line_data_all.extend(line_data)

            colors = plotly.colors.qualitative.Plotly

            if neighbor_eval:
                sev_order = ["Low", "Medium", "High"]
                x_idx = [0, 1, 2]
                color_map = {"Low": "green", "Medium": "orange", "High": "red"}

                stats = {}
                for sev in sev_order:
                    depths = np.array([it["depth"] for it in line_data_all if it["severity"] == sev], dtype=float)
                    stats[sev] = {
                        "count_ruts": int(depths.size),
                        "mean_depth": float(np.nanmean(depths)) if depths.size else np.nan,
                        "std_depth":  float(np.nanstd(depths))  if depths.size else np.nan,
                    }

                sev_totals = {sev: [r["Total Area (ft²)"]
                                    for r in neighbor_summary_rows
                                    if r["Severity"] == sev and r["Count"] > 0]
                              for sev in sev_order}
                sev_total_mean = {sev: (float(np.nanmean(sev_totals[sev])) if len(sev_totals[sev]) else np.nan)
                                  for sev in sev_order}
                sev_total_std  = {sev: (float(np.nanstd(sev_totals[sev])) if len(sev_totals[sev]) else np.nan)
                                  for sev in sev_order}
                sev_total_n    = {sev: int(len(sev_totals[sev])) for sev in sev_order}

                neighbor_summary_rows.sort(key=lambda r, o=sev_order: (r["Frequency"], o.index(r["Severity"])))
                table_cols = {
                    "Frequency": [r["Frequency"] for r in neighbor_summary_rows],
                    "Severity": [r["Severity"] for r in neighbor_summary_rows],
                    "Count": [r["Count"] for r in neighbor_summary_rows],
                    "Mean Depth, in": [None if np.isnan(r["Mean Depth (in)"]) else round(r["Mean Depth (in)"], 4) for r in neighbor_summary_rows],
                    "Std Depth, in": [None if np.isnan(r["Std Depth (in)"]) else round(r["Std Depth (in)"], 4) for r in neighbor_summary_rows],
                    "Mean Area, ft²": [None if np.isnan(r["Mean Area (ft²)"]) else round(r["Mean Area (ft²)"], 4) for r in neighbor_summary_rows],
                    "Std Area, ft²": [None if np.isnan(r["Std Area (ft²)"]) else round(r["Std Area (ft²)"], 4) for r in neighbor_summary_rows],
                    "Total Area, ft²": [round(r["Total Area (ft²)"], 4) for r in neighbor_summary_rows],
                    "Total Area Std by Severity, ft²": [None if np.isnan(sev_total_std[r["Severity"]]) else round(sev_total_std[r["Severity"]], 4) for r in neighbor_summary_rows],
                }

                def add_band(fig, row, col, x_center, y_mean, y_std, clamp_zero=False, width=0.35, color_hex="gray"):
                    if np.isnan(y_mean) or np.isnan(y_std):
                        return
                    y0 = y_mean - y_std
                    y1 = y_mean + y_std
                    if clamp_zero:
                        y0 = max(0.0, y0)
                    fig.add_shape(
                        type="rect",
                        x0=x_center - width, x1=x_center + width,
                        y0=y0, y1=y1,
                        fillcolor=color_hex, opacity=0.2, line=dict(width=0),
                        row=row, col=col
                    )

                fig = make_subplots(
                    rows=2, cols=2,
                    subplot_titles=[
                        "Mean depth with standard deviation, by severity",
                        "Total area with standard deviation, by severity",
                        "Details per frequency and severity", ""
                    ],
                    specs=[
                        [{'type': 'xy'}, {'type': 'xy'}],
                        [{'type': 'table', 'colspan': 2}, None]
                    ],
                    row_heights=[0.55, 0.45],
                    vertical_spacing=0.08
                )

                depth_means = [stats[s]["mean_depth"] for s in sev_order]
                for i, sev in enumerate(sev_order):
                    add_band(fig, row=1, col=1, x_center=x_idx[i],
                             y_mean=stats[sev]["mean_depth"],
                             y_std=stats[sev]["std_depth"],
                             clamp_zero=False,
                             color_hex=color_map[sev])
                fig.add_trace(
                    go.Scatter(
                        x=x_idx, y=depth_means,
                        mode="lines+markers",
                        name="Mean depth",
                        marker=dict(size=8),
                        line=dict(width=2)
                    ),
                    row=1, col=1
                )
                fig.update_xaxes(
                    row=1, col=1,
                    tickmode="array",
                    tickvals=x_idx,
                    ticktext=sev_order,
                    title_text="Severity"
                )
                fig.update_yaxes(row=1, col=1, title_text="Depth, inches")

                area_tot_means = [sev_total_mean[s] for s in sev_order]
                for i, sev in enumerate(sev_order):
                    add_band(fig, row=1, col=2, x_center=x_idx[i],
                             y_mean=sev_total_mean[sev],
                             y_std=sev_total_std[sev],
                             clamp_zero=True,
                             color_hex=color_map[sev])
                fig.add_trace(
                    go.Scatter(
                        x=x_idx, y=area_tot_means,
                        mode="lines+markers",
                        name="Total area",
                        marker=dict(size=8),
                        line=dict(width=2)
                    ),
                    row=1, col=2
                )
                fig.update_xaxes(
                    row=1, col=2,
                    tickmode="array",
                    tickvals=x_idx,
                    ticktext=sev_order,
                    title_text="Severity"
                )
                fig.update_yaxes(row=1, col=2, title_text="Total area, square feet")

                for i, sev in enumerate(sev_order):
                    mu = sev_total_mean[sev]
                    sd = sev_total_std[sev]
                    n  = sev_total_n[sev]
                    if not np.isnan(mu):
                        y_label = max(0.0, mu + (0.0 if np.isnan(sd) else sd))
                        fig.add_annotation(
                            x=x_idx[i],
                            y=y_label,
                            text=f"{sev}<br>mean {mu:.2f} ft², std {0.0 if np.isnan(sd) else sd:.2f}, n {n}",
                            showarrow=False,
                            yshift=8,
                            font=dict(size=11),
                            row=1, col=2
                        )

                fig.add_trace(go.Table(
                    header=dict(
                        values=list(table_cols.keys()),
                        fill_color='paleturquoise',
                        align='left',
                        font=dict(size=12)
                    ),
                    cells=dict(
                        values=[table_cols[k] for k in table_cols.keys()],
                        fill_color='lavender',
                        align='left',
                        font=dict(size=11)
                    )
                ), row=2, col=1)

                fig.update_layout(
                    title="Rutting severity, neighbor frequency study, pooled results",
                    height=880,
                    showlegend=False,
                    template="simple_white",
                    margin=dict(l=60, r=60, t=80, b=60)
                )

            else:
                # limit the number of elevation panels for readability when lines are many
                total_lines = len(elevation_plots)
                if total_lines > 30:
                    desired = 10
                    idxs = np.linspace(0, total_lines - 1, desired, dtype=int).tolist()
                    plotted_plots = [elevation_plots[i] for i in idxs]
                    arcpy.AddMessage(f"Large area detected, total vertical lines with ruts, {total_lines}. Plotting a readable subset of {desired} evenly spaced profiles.")
                else:
                    plotted_plots = elevation_plots

                num_plots = len(plotted_plots)
                if num_plots == 0:
                    fig = make_subplots(
                        rows=1, cols=2,
                        subplot_titles=("Details of All Ruts", ""),
                        specs=[[{'type': 'table'}, {'type': 'domain'}]],
                        column_widths=[0.7, 0.3]
                    )
                    total_height = 400
                    table_row = 1
                    table_col = 1
                    annotation_x = 0.85
                    annotation_y = 0.5
                else:
                    cols_per_row = 3
                    num_rows = math.ceil(num_plots / cols_per_row)
                    total_rows = num_rows + 1
                    max_spacing = 1 / (total_rows - 1) if total_rows > 1 else 0.05
                    vertical_spacing = min(0.03, max_spacing)
                    specs = [[{'type': 'xy'} if (row * cols_per_row + col) < num_plots else None
                              for col in range(cols_per_row)] for row in range(num_rows)]
                    specs.append([{'type': 'table', 'colspan': 2}, None, {'type': 'domain'}])
                    row_heights = [0.7 / num_rows] * num_rows + [0.3]
                    subplot_titles = [f"Elevation at x, {plot['line_x']} m" for plot in plotted_plots] + ["Details of All Ruts", ""]
                    fig = make_subplots(
                        rows=total_rows,
                        cols=cols_per_row,
                        subplot_titles=subplot_titles,
                        row_heights=row_heights,
                        specs=specs,
                        vertical_spacing=vertical_spacing,
                        column_widths=[0.333, 0.333, 0.333]
                    )
                    total_height = 300 * total_rows
                    table_row = total_rows
                    table_col = 1
                    annotation_x = 0.85
                    annotation_y = (1 - sum(row_heights[:-1])) / 2

                if plotted_plots:
                    colors = plotly.colors.qualitative.Plotly
                    num_colors = len(colors)
                    for i, plot in enumerate(plotted_plots):
                        row = (i // 3) + 1
                        col = (i % 3) + 1
                        line_color = colors[i % num_colors]
                        fill_color = hex_to_rgba(line_color, 0.20)

                        baseline = float(np.nanmin(plot["depths"]))
                        base_y = [baseline] * len(plot["sections"])

                        fig.add_trace(go.Scatter(
                            x=plot["sections"],
                            y=base_y,
                            mode='lines',
                            line=dict(width=0),
                            hoverinfo='skip',
                            showlegend=False
                        ), row=row, col=col)

                        fig.add_trace(go.Scatter(
                            x=plot["sections"],
                            y=plot["depths"],
                            mode='lines',
                            name=f'Elevation at x, {plot["line_x"]} m',
                            line=dict(color=line_color, width=2),
                            fill='tonexty',
                            fillcolor=fill_color
                        ), row=row, col=col)

                        for rut in plot["ruts"]:
                            rut_area_sqft, idx_h1, idx_low, idx_h2, rut_depth_m, rut_depth_in = rut
                            color = 'green' if rut_depth_in < 1.0 else 'orange' if rut_depth_in <= 3.0 else 'red'
                            severity_label = 'Low' if 0.5 < rut_depth_in < 1.0 else 'Medium' if rut_depth_in <= 3.0 else 'High'
                            fig.add_shape(
                                type="line",
                                x0=idx_low, x1=idx_low,
                                y0=min(plot["depths"]), y1=max(plot["depths"]),
                                line=dict(color=color, width=2, dash="dash"),
                                row=row, col=col
                            )
                            fig.add_annotation(
                                x=idx_low,
                                y=max(plot["depths"]),
                                text=severity_label,
                                showarrow=True,
                                arrowhead=1,
                                arrowsize=1,
                                arrowwidth=1,
                                arrowcolor=color,
                                ax=0,
                                ay=-30,
                                font=dict(size=10, color=color),
                                row=row, col=col
                            )

                table_data = {
                    "Line X, m": [item["line_x"] for item in line_data_all],
                    "Depth, in": [item["depth"] for item in line_data_all],
                    "Area, ft²": [item["area"] for item in line_data_all],
                    "Severity": [item["severity"] for item in line_data_all]
                }
                fig.add_trace(go.Table(
                    header=dict(
                        values=["Line X, m", "Depth, in", "Area, ft²", "Severity"],
                        fill_color='paleturquoise',
                        align='left',
                        font=dict(size=12)
                    ),
                    cells=dict(
                        values=[
                            table_data["Line X, m"],
                            table_data["Depth, in"],
                            table_data["Area, ft²"],
                            table_data["Severity"]
                        ],
                        fill_color='lavender',
                        align='left',
                        font=dict(size=11)
                    )
                ), row=table_row, col=table_col)

                num_plots = len(plotted_plots)
                for i in range(num_plots):
                    row = (i // 3) + 1
                    col = (i % 3) + 1
                    fig.update_yaxes(title_text="Elevation, meters", row=row, col=col, title_font=dict(size=10))
                    fig.update_xaxes(title_text="Section Index", row=row, col=col, title_font=dict(size=10))

                totals = {"Low": 0.0, "Medium": 0.0, "High": 0.0}
                for item in line_data_all:
                    if item["severity"] in totals:
                        totals[item["severity"]] += item["area"]
                area_text = "\n".join([f"{sev}, {totals.get(sev, 0):.2f} ft²" for sev in ["Low", "Medium", "High"]])
                fig.add_annotation(
                    x=annotation_x, y=annotation_y, xref="paper", yref="paper",
                    text=f"Total Severity Areas\n{area_text}",
                    showarrow=False, align="center", bgcolor="white", bordercolor="black", borderwidth=1,
                    font=dict(size=14, color="black"),
                    xanchor="center", yanchor="middle"
                )

                fig.update_layout(
                    title="Rutting Severity Analysis Across Polygon",
                    height=total_height,
                    showlegend=True,
                    template="simple_white",
                    margin=dict(l=60, r=100, t=100, b=60)
                )

            fig.write_html(output_html)
            arcpy.AddMessage(f"Plot saved to, {output_html}")
            arcpy.AddMessage("Rutting severity detection for polygon complete.")

        except Exception as e:
            raise arcpy.ExecuteError(f"Execution failed, {str(e)}")

class Toolbox(object):
    def __init__(self):
        self.label = "TESTING TOOLBOX"
        self.alias = "testing_toolbox"
        self.tools = [RuttingPolygonTool]

class ToolValidator(object):
    def __init__(self):
        self.params = None

    def initializeParameters(self, parameters):
        self.params = parameters
        return

    def updateParameters(self, parameters):
        if parameters[6].valueAsText:
            output_path = parameters[6].valueAsText
            if not output_path.lower().endswith('.html'):
                parameters[6].value = output_path + '.html'
        return

    def updateMessages(self, parameters):
        if parameters[0].valueAsText:
            desc = arcpy.Describe(parameters[0].valueAsText)
            if desc.shapeType != "Polygon":
                parameters[0].setErrorMessage("Input feature must be a polygon.")

        if parameters[1].valueAsText:
            dem_path = parameters[1].valueAsText
            if not os.path.exists(dem_path):
                parameters[1].setErrorMessage("DEM file does not exist.")
            elif not dem_path.lower().endswith(('.tif', '.tiff', '.img')):
                parameters[1].setWarningMessage("DEM file should be a raster format, for example .tif or .img.")

        if parameters[2].value is not None and int(parameters[2].value) <= 0:
            parameters[2].setErrorMessage("Sampling frequency per 100 pixels must be greater than zero.")

        if parameters[3].value is not None and float(parameters[3].value) <= 0:
            parameters[3].setErrorMessage("Rutting width must be greater than zero.")

        if parameters[5].value is not None and int(parameters[5].value) < 1:
            parameters[5].setWarningMessage("Neighbor range is less than one, it will be clamped to one at run time.")

        if parameters[6].valueAsText:
            output_path = parameters[6].valueAsText
            if not output_path.lower().endswith('.html'):
                parameters[6].setErrorMessage("Output file must have a .html extension.")
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                parameters[6].setErrorMessage("Output directory does not exist.")
        return
